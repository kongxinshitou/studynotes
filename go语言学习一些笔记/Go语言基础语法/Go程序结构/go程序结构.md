#### 1.名称

* 命名规则
  * 名字的开头是一个字母或者下划线后面可以跟任意数量的字符，数字，下划线
  * 25个关键字不能作为名称
  * 有三十几个内置的预声明的常量，类型，函数。
* 包名由小写字符组成
* 实体在函数中声明，只在函数局部有效，在函数外面声明，对包里面的所有源文件可见。
* 实体第一个字母大小写决定可见性是否跨包，大写是对包外可见和可访问的。

```go
import "fmt"
fmt.Printf("Printf是大写开头，所以大伙儿就可以用")
```

* go命名风格

  * 尽量短

  * 驼峰式

    ```go
    iLoveChifan
    而不是i_LOVE_CHIfan
    ```

#### 2.声明

* 四个声明
  * 变量(var）
  * 常量(const)
  * 类型(type)
  * 函数(func)
* 声明顺序
  1. package
  2. import
  3. 包级别的类型，变量，常量
  4. 函数和里面的局部变量

#### 3.变量

```go
var name type = expression
//类型和表达式可以省略一个
//类型省略，数字类型由表达式决定
//如果表达式省略，初始值对应0值

```

* 零值
  * 数字0
  * 布尔值false
  * 字符串""
  * 接口应用类型nil
  * 数组或者结构体，零值是多有元素或者成员的零值
* go里面不存在未初始化变量，因为没定义就是零值
* 声明变量列表

```go
var b,f,s = true,2.3,"four" // bool,float64,string
```

##### 3.1短变量声明

```go
name := expression
i := 1
//局部变量的声明和初始化多用短变量初始化
i,j := 0,1
//多个变量也可以用
i,j = j, i //i,j交换，不是赋值,赋值是=
f, err := os.Open(name)
//可以通过函数的返回来声明
```

* 如果变量在同一词法块声明，对于变量，短声明等价于赋值

```go
i,j := 1,2//i,j都是声明
j,k := 5,6//j是赋值,k是声明
```

* 短变量声明最少声明一个新变量，否则代码编译通不过

```go
i,j := 1,2
i,j := 5,6
//编译不通过
```

#####3.2指针

* 指针类型如(*int)指向整型变量的指针

```go
a := 1
p := &a//&取地址，p是指向a的指针
*p//访问a
```

* 指针的零值是nil两个指针只有指向同一个变量或者两者都是nil才相等

##### 3.3new函数

```go
p := new(int)//*int类型的p
```

##### 3.4变量的生命周期

* 包级别的声明周期:整个程序的执行时间
* 局部变量的声明周期:变量生存到它不可访问

``` go
var global *int
func f() {
  var x int
  x = 1
  global = &x
}
//x使用堆空间，因为他在f函数返回以后还可以从global变量访问，x从f中逃逸
func g() {
  y := new(int)
  *y = 1
}
//g返回时，*y变得不可访问，可以回收，所以用的栈空间。
```

#### 4.赋值

```go
=
+=
*=
--
//c都可以用的哦
```

##### 4.1多重赋值

```go
x, y = 1+1,1+2//x=2,y=3
//赋值前右边表达式被推演
```

##### 4.2可赋值性

* 类型必须精准匹配
* nil可以被赋给任何接口变量或引用类型

#### 5.类型声明

* type声明定义一个新的命名类型，它和某个已有类型使用相同的底层类型

```go
type name underlying-type
```

* 如果两个类型具有相同的底层类型或二者都是指向相同底层类型变量的未命名指针类型，则两者可以相互转换

##### 6.包和文件

* 一个包的源文件保存在一个或多个以.go结尾的文件中
* 每一个包给它的声明提供独立的命名空间
* 导出的标识符以大写字母开头

##### 6.2包的初始化

* 包的初始化在依赖已解析完毕的情况下，根据依赖的顺序进行。

##### 7.作用域

* 声明的作用域:声明在程序文本中出现的区域，他是一个编译时属性
* 变量的生命周期:变量在程序执行期间能被程序的其他部分所引用的起止时间，它是一个运行时属性。
* 当编译器遇到引用，从最内层的封闭词法块到全局块寻找声明，如果内层和外层块都存在这个声明，内层声明将会覆盖外部声明。